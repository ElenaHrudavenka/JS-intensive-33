# JS-intensive-33

1) Какие бывают алгоритмы сортировок?

***<u>Поразрядная сортировка</u>*** - сначала делим данные по разрядам, а потом сортируем их внутри каждого разряда.
Для этого нужно заранее выяснить два момента: сколько элементов в массиве и сколько разрядов у самого длинного
элемента. Создать промежуточный массив с 10 пустыми ячейками (10 — выбранное основание системы счисления).
Найти все значения первого разряда в каждом числе и положить соответствующие числа в ячейки под этими номерами.
Заменить содержимое исходного массива этими непустыми значениями. Так для каждого разряда. Выполняется за
**линейное время**.


***<u>Пузырьковая сортировка</u>*** - заключается в последовательном сравнении значений соседних элементов и мы меняем
числа местами, если предыдущее оказывается больше последующего. Таким образом элементы с большими
значениями оказываются в конце списка, а с меньшими остаются в начале (почти не применяется на практике
из-за низкой эффективности).


***<u>Сортировка перемешиванием (шейкерная сортировка)</u>*** - шейкерная сортировка отличается от пузырьковой тем,
что она двунаправленная: алгоритм перемещается не строго слева направо, а сначала слева направо, затем
справа налево.


***<u>Сортировка расчёской</u>*** - если при пузырьковой и шейкерной сортировках при переборе массива сравниваются
соседние элементы, то при «расчёсывании» сначала берётся достаточно большое расстояние между сравниваемыми
значениями, а потом оно сужается вплоть до минимального. Первоначальный разрыв нужно выбирать не случайным
образом, а с учётом специальной величины — фактора уменьшения, оптимальное значение которого равно 1,247.
Сначала расстояние между элементами будет равняться размеру массива, поделённому на 1,247; на каждом последующем
шаге расстояние будет снова делиться на фактор уменьшения — и так до окончания работы алгоритма.


При ***<u>сортировке вставками</u>*** массив постепенно перебирается слева направо. При этом каждый последующий элемент
размещается так, чтобы он оказался между ближайшими элементами с минимальным и максимальным значением.


***<u>Сортировка выбором</u>*** - Сначала нужно рассмотреть подмножество массива и найти в нём максимум (или минимум).
Затем выбранное значение меняют местами со значением первого неотсортированного элемента. Этот шаг нужно
повторять до тех пор, пока в массиве не закончатся неотсортированные подмассивы.


***<u>Быстрая сортировка</u>*** - Этот алгоритм состоит из трёх шагов. Сначала из массива нужно выбрать один элемент — его
обычно называют опорным. Затем другие элементы в массиве перераспределяют так, чтобы элементы меньше опорного
оказались до него, а большие или равные — после. А дальше рекурсивно применяют первые два шага к подмассивам
справа и слева от опорного значения.


***<u>Сортировка слиянием</u>*** - Сортировка слиянием пригодится для таких структур данных, в которых доступ к элементам
осуществляется последовательно (например, для потоков). Здесь массив разбивается на две примерно равные части
и каждая из них сортируется по отдельности. Затем два отсортированных подмассива сливаются в один.


***<u>Пирамидальная сортировка</u>*** - При этой сортировке сначала строится пирамида из элементов исходного массива.
Пирамида (или двоичная куча) — это способ представления элементов, при котором от каждого узла может отходить
не больше двух ответвлений. А значение в родительском узле должно быть больше значений в его двух дочерних узлах.
Пирамидальная сортировка похожа на сортировку выбором, где мы сначала ищем максимальный элемент, а затем помещаем
его в конец. Дальше нужно рекурсивно повторять ту же операцию для оставшихся элементов.


2) Прочитать про "Операторы и выражения, циклы в JS"

3) Создать объект Person несколькими способами, после создать объект Person2, чтобы в нём были доступны методы объекта Person. Добавить метод logInfo чтоб он был доступен всем объектам.
```js
       function Person(name, age) {
        this.name = name;
        this.age = age;
        this.sayHello = function () {
            console.log(`Hello, ${this.name}`)
        }
    }
    Object.prototype.logInfo = function() {
        console.log(`Info about ${this.name} has been added.`);
    }
    const person = new Person('Ilya', 11);
    const person2 = {name: 'Sasha'};
    person.sayHello.call(person2); // 'Hello, Sasha'
    person.sayHello(); // 'Hello, Ilya'
    person.logInfo(); // ''
```
```js
        class Person {
        constructor(name, age) {
            this.name = name;
            this.age = age;
        }
        sayHello() {
            console.log(`Hello, ${this.name}`);
        }
    }
    Object.prototype.logInfo = function() {
        console.log(`Info about ${this.name} has been added.`);
    }
    const person1 = new Person('Ilya', 11);
    const person2 = Object.create(person1, {name: {value: 'Nikita'}, age: {value: 11}});
    person1.sayHello(); // 'Hello, Ilya'
    person2.logInfo(); // 'Hello, Nikita'
```

```js
        const person = {
        name: 'Ilya',
        age: 11,
        sayHello () {
            console.log(`Hello, ${this.name}`)
        },
        sayGoodby () {
            console.log(`Goodby, ${this.name}`)
        },
    }
    Object.prototype.logInfo = function() {
        console.log(`Info about ${this.name} has been added.`);
    }
    
    const person1 = {name: 'Sasha', age: 35};
    const person2 = {};
    
    person1.__proto__=person; //не стоит использовать геттер/сеттер __proto__
    Object.setPrototypeOf(person2, person);
    
    person2.name = 'Nikita';
    person.sayGoodby(); // 'Goodby, Ilya'
    person1.logInfo(); // 'Info about Sasha has been added.'
    person2.sayGoodby(); // 'Goodby, Nikita'    
```

5) Создать класс PersonThree c get и set для поля name и конструктором, сделать класс наследник от класса Person.
```js
        class PersonThree {
        #name;
        constructor(name) {
            this.#name = name
        }
    
        set name(value) {
            if (!name) throw new Error('Name field should not be empty!');
            this.#name = value;
        }
    
        get name() {
            return this.#name;
        }
    }
    
    class Person extends PersonThree {
        constructor(name, age) {
            super(name);
            this.age = age;
        }
    }
    const firstPerson = new Person('Ilya', 11);
    const secondPerson = new Person('Nikita', 14)
    console.log(firstPerson) // Person {age: 11, #name: 'Ilya'}
    secondPerson.name // 'Nikita'

```

БОНУС:
1) Написать функцию, которая вернет массив с первой парой чисел, сумма которых равна total:
```js
    // Вариант 1
    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    total = 13;
    //result = [4, 9]
    const firstSum = (arr, total) => {
        for (let i = 0; i < arr.length; i++) {
            if (arr.includes(total - arr[i])) {
                return [arr[i], total - arr[i]]
            }
        }
        return 'The corresponding pair not found!';
    }
    
    firstSum(arr,total);
```
```js
    // Вариант2
    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    total = 13;
    //result = [4, 9]
    
    const firstSum = (arr, total) => {
        for (let i = 0; i < arr.length; i++) {
            if (arr[i] + arr[Math.ceil(arr.length/2)] < total) {
                for(let j = Math.ceil(arr.length/2); j<arr.length; j++) {
                    if (arr[i] + arr[j] === total) {
                        return [arr[i], arr[j]]
                    }
                }
            } else {
                for(let j = i+1; j < Math.ceil(arr.length/2); j++) {
                    if (arr[i] + arr[j] === total) {
                        return [arr[i], arr[j]]
                    }
                }
            }
        }
        return 'The corresponding pair not found!';
    }
    
    firstSum(arr,total);
```
2) Какая сложность у вашего алгоритма?
3) 
1. У нас есть цикл, который имеет линейную сложность О(n) и метод includes имеет линейную сложность О(n). 
Думаю, что сложность алгоритма О(n^2); Этот вариант будет работать с неотсортированным массивом.
2. Есть цикл, который имеет линейную сложность О(n). Есть вложенный цикл, который пройдет половину массива.
Этот вариант для отсортированного массива.
