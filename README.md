# JS-intensive-33

### 1) Подробно прочитать про метод запроса OPTIONS - и кратко его описать, когда вызывается, где используется, что передает и принимает. 
    OPTIONS запрашивает разрешенные параметры связи для данного URL-адреса или сервера. С помощью этого метода клиент может указать URL-адрес или 
    звездочку ( * ), чтобы ссылаться на весь сервер. Этот метод позволяет клиенту определять опции и/или требования, связанные с ресурсом, или 
    возможностями сервера, но не производя никаких действий над ресурсом и не инициируя его загрузку. Ответы на этот метод не кэшируются.
    Запрос не имеет тела. Является безопасным и идемпотентным.
    Данный метод используется браузерами для preflight запроса. Браузер сам подставляет заголовок Origin и выступает доверенным посредником, гарантируя  
    то, что источник запроса не модифицировали.
        - Origin - URL ресурса, с которого отправляем запрос;
        - Access-Control-Request-Method - уведомляет, что при отправке фактического запроса он будет отправлен определенным методом (напр. POST);
        - Access-Control-Request-Headers - с какими пользовательскими заголовками будет отправлен фактический запрос ( сервер имеет возможность 
        определять возможно ли принять запрос с такими параметрами);


        - Access-Control-Allow-Methods - какие методы запроса являются приемлемыми для данного ресурса;
        - Access-Control-Allow-Origin - если не вернет текущий URL или *, то браузер заблокирует ответ (Object Storage возвращает ошибку 403
        и отсутствуют все заголовки Access-Control-*);
        - Access-Control-Allow-Headers - Список HTTP-заголовков, которые можно использовать в последующем запросе к объекту. Если все заголовки запрещены, 
        то этот заголовок не входит в ответ.
        - Access-Control-Max-Age - допустимый период (в секундах) кэширования ответа.
    Также может содержать общие заголовки для запросов и ответов.
    
### 2) Прочитать и описать ключевые особенности "HTTP" Версии 3.0
    Один из главных причин появления HTTP 3.0 - это переход на протокол QUIC (его первоначальное название  HTTP-over-QUIC).
    А уже использование данного протокола дает основные приемущества и позволяет обойти ограничения, накладываемые использованием протокола TCP.
        - QUIC вводит понятие мультиплексирования нескольких потоков в одном соединении, т.е. реализует раздельное управление потоком для каждого потока, 
        что решает проблему блокировки начала очереди (HoL) всего соединения. (HTTP/2 решал только проблему HoL на уровне HTTP)
        - Контроль перегрузки QUIC является более гибким и позволяет более эффективно использовать доступную полосу пропускания сети, что приводит к 
        повышению пропускной способности трафика.
        - QUIC предлагает использовать усовершенствованный механизм восстановления после потерь и прямое исправление ошибок, чтобы справляться с 
        ошибочными пакетами
        - HTTP/3 также использует новый механизм сжатия заголовков (QPACK). В QPACK заголовки HTTP могут поступать не по порядку в разных потоках QUIC. 
        В отличие от HTTP/2, где TCP обеспечивает упорядоченную доставку пакетов, потоки QUIC доставляются не по порядку и могут содержать разные заголовки
        в разных потоках. Чтобы справиться с этим, QPACK использует механизм таблицы поиска для кодирования и декодирования заголовков.
        - Улучшенный push;
        - Установление соединения происходит быстрее;
    Для TCP + TLS требовались: TCP Handshake --> TLS Handshake --> передача данных (занимает как минимум два периода времени на передачу и подтверждение 
    приема (Round-Trip Times - RTT), что увеличивает задержку);
    Для UDP + QUIC: QUIC Handshake и передача данных за одно обращение (QUIC использует тот же модуль TLS, что и HTTP/2 для защищенного соединения, первое 
    зашифрованное соединение устанавливается на 1 RTT, а при возобновлении сеанса данные полезной нагрузки отправляются с первым пакетом при минимальном 
    нулевом RTT);

### 3) Прочитать про способы отмены запроса, включая объект "AbortController"
    AbortController - это интерфейс, который позволяет управлять отменой http запросов на стороне фронтенда. Взаимодействие с DOM запросами сделано
    с использованием объекта AbortSignal. Метод abort() интерфейса AbortController прерывает запрос (например Fetch запрос) до его завершения.
    (!) Когда abort() вызывается, fetch() промис отклоняется с AbortError.
        Использование:
        - создать констроллер (новый экземпляр AbortController) используя конструктор AbortController();
        - взять ссылку на ассоциированный с ним объект AbortSignal используя свойство AbortController.signal;
        - при инициализации fetch-запроса мы должны передать AbortSignal как параметр внутрь объекта параметров запроса (это ассоциирует наш контроллер
        и сигнал с конкретным запросом и дает нам возможность остановить запрос используя метод abort());
         
    Для XMLHttpRequest также есть метод abort(), который доступен во всех версиях объекта XMLHttpRequest. (При этом генерируется событие abort, 
    а xhr.status устанавливается в 0.)

### 3) Написать по 2 примера создания примитивных значений (если есть несколько способов - использовать) (string, number, boolean, null, undefined, symbol, bigInt)
    let str = 'Hello, world!';
    let str1 = "Hello, world!";
    let str2 = `Hello, world!`;
    const PORT = 3000;
    let maxCount = 1e6;
    let count = 0xFF;
    let isLoading = false;
    let isSmth = 5 > 3;
    let isSmth = !3;
    let firstName = null;
    let result;
    const id = Symbol();
    const id1 = Symbol("id1");
    let count = 25n; 
    Не указывала при помощи конструкторов, т.к. результат - не примитив.

### 4) Почему, если обратиться к переменным созданным через let, const до их объявления - мы получаем ReferenceError?
    Данная ошибка связана с понятием временная мертвая зона (temporal dead zone). Т.е. переменные объявленные при помощи ключевых слов let и const
    существуют во временной мертвой зоне с начала своей области видимости до места их объявления в коде. Если мы попробуем обратиться к переменной
    в TDZ, то мы получим ReferenceError.

### 5) Решить:

    const res = "B" + "a" + (1 - "hello");
    console.log(res); // 'BaNaN'

    const res2 = (true && 3) + "d";
    console.log(res2); // '3d'

    const res3 = Boolean(true && 3) + "d";
    console.log(res3); // 'trued'
