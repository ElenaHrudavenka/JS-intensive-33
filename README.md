# JS-intensive-33

Домашнее задание:

1) Почитать про принципы программирования KISS, DRY, YAGNI + почитать про "Антипаттерны" Чистого кода
   
***<u>KISS (Keep It Simple, Stupid)</u>*** - это принцип проектирования, который предполагает отказ от необоснованного усложнения
проектируемой системы в случае если мы можем сделать ее проще и легче. В простом коде проще искать ошибки, проще его
изменять, дорабатывать и сопровождать.
Нужно следовать правилам:
- большие задачи разбить на подзадачи (на разработку каждой из которых мы потратим не болеее 4-12 часов);
- подзадачи должны решать одну проблему;
- методы в идеале не более 30-50 строк;
- сперва хорошо продумать решение;
- не делать фич на всякий случай, я имею ввиду задачи, которые перед нами не стоят, но в теории могут возникнуть в 
дальнейшем. (!) В данном пункте хочу отметить, что если мы понимаем, что в дальнейшем нам может понабится какой-то 
функционал, реализовывать его без необходимости не стоит, а вот продумать возможности расширения и выбрать правильный 
подход стоит сразу;
- удалять ненужный и устаревший код.

KISS для React: 
- создавать компоненты небольшого размера;
- выносить логику во вспомогательные функции;
- для работы с использованием состояния — создавать кастомные хуки. 
Результат: компоненты небольшого размера (функции), вспомогательные функции малого размера, отдельные пользовательские
хуки (так же являются функциями). Вся логика вынесена в небольшие функции, которые в дальнейшем будет 
удобно покрыть unit тестами.

***<u>DRY (Don't repeat yourself)</u>*** - предполагает разделение крупной системы на более мелкие неповторяющиеся 
компоненты. Т.е. если у нас есть компонент, куссок кода, который повторяется, то мы должны привести его в соответствие
принципу DRY.
Правила:
- представьте проект в виде графической схемы, разделенной на визуальные компоненты;
- сложный компонент проекта следует представить графически (диаграммы UML или подобные средства);
- в графической схеме четко указать иерархию и роль каждого компонента проекта;
- связь ваших компонентов с компонентами других участников проекта, а также какие ветки проекта будет общими (public) 
или приватными (private);
- необходимо избегать жестких связей между компонентами, поскольку они негативно влияют на эффективность всей
архитектуры проекта.

***<u>YAGNI (You aren't gonna need it)</u>*** - полагает отказ от избыточной функциональности разрабатываемой вами 
системы, т.е. если нет непосредственной надобности в задаче или методе, то следует отказаться от них. Т.е. не нужно 
писать код, который вам может когда-нибудь пригодиться, вместо этого следует решать в первую очередь самые актуальные
и важные задачи.

***<u>Антипаттерн</u>*** — это термин, обозначающий приемы, которые НЕ нужно применять при решении задач.

- Спагетти-код — код с практически нулевой структурой. В нем ничего не модулируется. Файлы случайным образом 
разбросаны по случайным каталогам. Ход программы трудно проследить, он полностью переплетен как спагетти;
- Золотой молот - использование одного подхода для проектирования разных проектов с разным функционалом, языком 
разработки и разными потребностями. Суть в том, что подход который хорошо работает на одном проекте может быть 
малоэффективен или совсем не подходить для другого. У разных языков есть и общие подходы к решению задач, и свои 
собственные стандарты. Для каждого проекта нужно выбирать наиболее подходящий язык, продумывать архитектуру и
исследовать и пробовать новые инструменты, технологии и способы решения задач;
- Лодочный якорь - предполагает, что программисты оставляют неиспользуемый код в базе, потому что он может 
понадобиться им позже. Лишний или устаревший код увеличивает время сборки, а вы можете перепутать рабочий и 
нерабочий код.
- Мертвый код - есть часть кода или функция и мы понимаем что этот код делает, но не знаем контекста. По сути, 
мы можем прочесть и понять этот код, но не понятно, зачем он здесь. Например функция везде вызывается, но по сути 
ничего не делает, а висит только потому, что все ее боятся удалять, не зная для чего она нужна. Такой код можно 
назвать мертвым.
- Разрастание кода - предполагает наличие в коде объектов, которые существуют исключительно для вызова других, 
более важных объектов. Их можно назвать «объекты-посредники». Наличие таких объектов добавляет ненужный уровень 
абстракции и сбивает с толку.
- Божественный объект (иногда называют «швейцарским ножом») -божественные объекты делают слишком много.  На примере 
ножа. Нужен только для того, чтобы отрезать кусок веревки, но при этом в нем есть пилочка для ногтей, пила, пара 
пинцетов, ножницы, открывалка для бутылок и штопор.


2) Прочитать про способы хранения LocalStorage, SessionStorage и Cookie

***<u>LocalStorage</u>*** - объект, предоставляемый браузером, который позволяет хранить данные без срока действия, т.е.
данные не будут удалены после закрытия браузера. 
Минусы: ограничение на размер в 5МБ и данные хранятся в виде обычного текста, т.е. не защищены.
***<u>SessionStorage</u>*** - объект, предоставляемый браузером, который позволяет хранить данные, но с очень важным 
отличием от LocalStorage - данные, сохраненные в sessionStorage, удаляются после закрытия браузера. Подходит только
для хранения данных, которые актуальны только в рамках одной сессии. Имеет такие же ограничения по размеру и хранит
данные без защиты.
***<u>Cookie</u>*** - это небольшие текстовые файлы, которые веб-сайт может записать на компьютер пользователя.
Могут хранить небольшое количество данных (до 4КБ) и имеют срок действия, который можно установить при записи cookie.
Является частью HTTP-протокола (используется в авторизациях для отслеживания посещений сайта и сохранения данных о 
покупках). Веб сервер устанавливает куки, используя заголовок Set-Cookie, после чего браузер начинает автоматически 
добавлять их в каждый запрос, который будет производится на текущем домене. Cookies могут быть доступны на всех 
страницах сайта и сохраняться между сессиями, что делает их идеальными для идентификации пользователя. 
Однако они могут быть отключены пользователем, что делает их ненадежным методом хранения.

3) HTML / CSS - Базовая структура html документа, БЭМ методология 

Простейшая HTML-страница состоит как минимум из трёх тегов: <html>, <head> и <body>. 
Еще один важный тег <!DOCTYPE html> - служебная информация для браузера(стандарт HTML), который нужно обработать.
- Тег <head> обычно содержит заголовок (<title>), ключевые слова, описание страницы и другие служебные данные (<meta>). 
Также внутри него подключаются внешние ресурсы например, стили (для подключения стилей к странице существует тег <link>). 
Содержимое этого тега не отображается на странице напрямую. 
- В теге <body> хранится содержание страницы, которое отображается в окне браузера.

```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Заголовок страницы</title>
</head>
<body>
    // тут будет разметка, которая отобразиться на странице
</body>
</html>
```

БЭМ (Блок, Элемент, Модификатор) - компонентный подход к веб-разработке. В его основе лежит принцип разделения интерфейса
на независимые блоки. Позволяет создавать расширяемые и повторно используемые компоненты интерфейса.
Методология БЭМ создана в Яндексе. 

4) Почитать про паттерны функционального программирования + посмотреть примеры использования

- <u>Неизменяемость данных</u> - при изменении данных создается новый объект;
- <u>Чистые функции</u> -  функции, которые не имеют побочных эффектов и всегда возвращают одинаковый результат при одинаковых 
входных данных. Такие функции легко тестировать и сопровождать.
- <u>Композиция функций</u> - процесс объединения нескольких функций в одну (для создания более сложных функций и повторного
использования кода);
- <u>Функции высшего порядка</u> - функции, которые принимают другие функции в качестве аргументов или возвращают функции
в качестве результата (для создания более абстрактного кода и повышения его гибкости);
- <u>Рекурсия</u> - процесс, при котором функция вызывает саму себя;

4) Способы позиционирования контента на странице

Позиционироание позволяет изымать элементы из нормального потока макета документа и заставляет их вести себя по-другому;

- <u>position:</u> static - стандартное поведени элементов. Поставить в потоке в нормальное положение;

- <u>position:</u> relative - относительное поозиционирование. Позволяет модифицировать окончательное положение позиционируемого
объекта, занявшего своё место в макете нормального потока, в том числе позволяет перекрывать другие элементы на странице.

- <u>position:</u> absolute - абсолютно позиционированный элемент больше не существует в нормальном потоке макета документа, 
располагается на своём собственном слое отдельно от всего остального.

- <u>position:</u> fixed - фиксированное позиционированиее. Работает точно также как и абсолютное позиционирование, одним 
ключевым отличием: в то время как абсолютное позиционирование фиксирует элемент в месте относительно его ближайшего 
позиционированного предка (исходный содержащий блок если нет иного), фиксированное позиционирование обычно фиксирует 
элемент в месте относительно видимой части области просмотра, кроме случаев, когда один из его потомков является 
фиксированным блоком из-за того, что его свойству transform отличается от none.

- <u>position:</u> sticky - это гибрид относительной и фиксированной позиции. Позволяет позиционируемому элементу вести себя 
как будто он относительно позиционирован, до тех пор пока он не будет прокручен до определённой пороговой точки 
(например, 10px от вершины окна просмотра), после чего он становится фиксированным.


7) Веса селекторов
Существует понятие специфичности. Когда свойство, объявленное ниже в коде, перекрывается тем, что объявленно выше, 
потому что селектор первого более специфичен, т.е. имеет больший вес.
Специфичность селектора рассчитывается по 4-м позициям: 

1,0,0,0  - inline-стили имеют самый большой вес (style="");

0,1,0,0 - селектор по ID перевесит всё, кроме inline-стилей (#id);

0,0,1,0 - селектор по классу (.class);

0,0,1,0 - селектор по аттрибуту ([attr=value]);

0,0,0,1 - селектор по тегу (LI);

0,0,0,0 - универсальный селектор (*), псевдокласс :where(), комбинаторы (+, >, ~, '``') не влияют на специфичность.

Переопределить стили, заданные в style, можно дописав !important к значению свойства, но (!) читала что это значение 
нужно стараться избегать. Мы должны использовать ткаое поведение CSS (я про специфичность) как его приемущество, 
а не как недостаток. А использование  !important нарушает эту логику.

Псевдоклассы :is(), :has() и :not() принимают вес наиболее специфичного селектора внутри скобок.
