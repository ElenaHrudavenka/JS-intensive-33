# JS-intensive-33

1) Написать ответ - почему массивы в JS являются "неправильными" и совмещают в себе несколько структур данных? Какие?


   Явного типа данных "массив" в JS нет. Массив - это объект(!) типа Array. Массивы и объекты — это ссылочные типы, 
   которые хранятся в памяти отдельно. Область хранения называется кучей, и в начале работы программы она пуста.
   Каждая ячейка в куче - это переменная, с собственным адресом (ее порядковый номер) которая может хранить одно(!) значение.  
   При создании нового массива интерпритатор размещает его в свободном месте кучи и записывает в переменную адрес массива. 
   В самой первой ячейке будет храниться длина массива, а дальше последовательно значения его элементов. Определение длины 
   массива и обращение к его элементу по индексу, за счет этого, две простые операции.

   Если нам нужно добавить элементы и в куче, после уже записанного массива есть достаточное количество свободных ячеек, 
   то данные будут последовательно записаны в них, если нето, то а самом деле при вызове метода push() интерпретатор копирует
   весь массив в свободную область памяти и добавляет к ней несколько элементов. Исходная область памяти помечается как 
   свободная. (Думаю, по этой причине на лекции ты говорил, что лучше создать массив определенной длинны, если мы заранее знаем, 
   какой длины массив нам нужен.)
   
   ВЫВОДЫ: JavaScript-массивы, на самом деле, очень похожи на ***списки***. Массивы в JS — это не просто некие простейшие
   структуры данных. Они, как и функции, являются объектами первого класса. У них есть методы, позволяющие адекватно решать 
   различные задачи. Используя разные комбинации этих методов, с массивами можно работать как со <u>***стеками***</u> или <u>***очередями***</u>.
   Методы массива для ***стека***:
    - push — вставка нового элемента в стек; (O(1))
    - pop — удаление самого последнего элемента из стека; (O(1))

   Методы массива для ***очереди***:
    - push — вставка нового элемента в очередь; (O(1))
    - shift — удаление первого элемента из очереди; (O(n))

   Я думаю, что "неправильными" массивы в js можно назвать по следующим причинам:
   - В JavaScript массивы имеют переменную длину, т.е. она не фиксирована.
   - Тип их содержимого не контролируется, т.е. элементы одного массива могут быть значениями разных типов (плохая практика(!))
   

2) Привязать контекст объекта к функции logger, чтобы при вызове this.item выводило - some value (Привязать через bind, call, apply)

```js
    function logger() {
    console.log(`I output only external context: ${this.item}`);
    }

    const obj = { item: "some value" };
    
    (logger.bind(obj))();
    logger.apply(obj);
    logger.call(obj);
```

Бонус задание: Реализовать полифил(собственную функцию реализующую встроенную в js) метода bind()
Когда искала способы реализации данного полифила, встречала реализации при помощи методов call/apply (напр. на MDN Web Docs). 
```js
    if (!Function.prototype.bind) {
        Function.prototype.bind = function(context, ...args) {
            let object = {...context};
            let symbol = Symbol('target');
            object[symbol] = this;
            return function(...rest) {
                return object[symbol](...args, ...rest);
            };
        };
    };
    function sayHello() {
        console.log(`Hello, ${this.name}.`)
    };
    
    const obj1 = {
        name: 'Alena',
    };
    const obj2 = {
        name: 'Tatsiana',
    };
    
    sayHello.bind(obj1).bind(obj2).bind({name: 'Ilya',})(); //Hello, Alena.
    const sayH = sayHello.bind(obj2).bind({name: 'Ilya',});
    setTimeout(sayH, 5000); //Hello, Tatsiana.
```
